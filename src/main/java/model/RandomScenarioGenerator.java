package model; //Created by Armin (github.com/arminkz)

import org.apache.commons.math3.random.HaltonSequenceGenerator;

import graph.Graph;
import graph.Vertex;

import java.awt.*;
import java.io.*;
import java.util.ArrayList;
import java.util.Random;

public class RandomScenarioGenerator {

    public RandomScenarioGenerator() {
    }

    //Generates a random scenario using WSN wireless range model and writes the result to scenario directory
    //note: sink_types is not generated by this tool and must be added manually or by other means
    public static void generate(String scenario_name, int sensor_count, int sc_count, int tx, int ty, double wireless_range){

        //TODO: this data should not be hard coded
        String[] possibleSensorStrings = {
                "1,2,0,0,200",
                "2,3,20,500,300",
                "2,3,30,500,500",
                "1,2,0,0,200",
                "1,3,0,0,400",
                "2,2,60,6600,300",
                "2,3,40,700,400",
                "2,3,50,700,400",
                "1,2,0,0,150"
        };

        File directory = new File("data/" + scenario_name);
        File graphFile = new File("data/" + scenario_name + "/graph.csv");
        File sensorsFile = new File("data/" + scenario_name + "/sensors.csv");
        File sinkTypesFile = new File("data/" + scenario_name + "/sink_types.csv");
        File sinksFile = new File("data/" + scenario_name + "/sinks.csv");

        //create files if there are not present
        try {
            if(!directory.exists()) directory.mkdir();
            if(!graphFile.exists()) graphFile.createNewFile();
            if(!sensorsFile.exists()) sensorsFile.createNewFile();
            if(!sinksFile.exists()) sinksFile.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }


        //Graph g = new Graph();
        ArrayList<Point> placmentPoints = new ArrayList<>();
        ArrayList<Vertex> vertices = new ArrayList<>();
        int n = sensor_count + sc_count;
        Random rnd = new Random(77);
        HaltonSequenceGenerator halton = new HaltonSequenceGenerator(2);

        for (int i = 0; i < n; i++) {
            double[] vec = halton.nextVector();
            int px = (int)(vec[0] * tx);
            int py = (int)(vec[1] * ty);
            Point pt = new Point(px,py);
            placmentPoints.add(pt);
            Vertex v = new Vertex();
            v.setPos(pt);
            vertices.add(v);
        }

        // write graph to file
        try {
            BufferedWriter wrt = new BufferedWriter(new FileWriter(graphFile));
            //write headers
            wrt.write("start,end,weight\n");
            for (int i = 0; i < n; i++) {
                for (int j = i+1; j < n; j++) {
                    Point p1 = placmentPoints.get(i);
                    Point p2 = placmentPoints.get(j);
                    double dist = Math.hypot(p2.x-p1.x,p2.y-p1.y);
                    if(dist <= wireless_range) {
                        //create edge and write to file
                        wrt.write(i+","+j+",1"); // use weight 1 for now
                        wrt.newLine();
                        //g.addEdge(g.getVertices().get(i),g.getVertices().get(j),1);
                    }
                }
            }
            wrt.flush();
            wrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


        //place sink candidates
        ArrayList<Integer> possibleSCs = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            possibleSCs.add(i);
        }

        //write chosen sinks to file
        try {
            BufferedWriter wrt = new BufferedWriter(new FileWriter(sinksFile));
            //write headers
            wrt.write("vertex,(posx),(posy)\n");
            for (int i = 0; i < sc_count; i++) {
                int k = rnd.nextInt(possibleSCs.size());
                int index = possibleSCs.get(k);
                possibleSCs.remove(k);
                Point pos = vertices.get(index).getPos();
                //place a sink candidate on index
                wrt.write(String.valueOf(index) + "," + pos.x + "," + pos.y);
                wrt.newLine();
            }
            wrt.flush();
            wrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        //write sensors to file
        try {
            BufferedWriter wrt = new BufferedWriter(new FileWriter(sensorsFile));
            //write headers
            wrt.write("vertex,name,kc,maxl,cpu,ram,bw,(posx),(posy)\n");
            for (int i = 0; i < possibleSCs.size(); i++) {
                int index = possibleSCs.get(i);
                // choose one random sensor string
                String sensorSpec = possibleSensorStrings[rnd.nextInt(possibleSensorStrings.length)];
                Point pos = vertices.get(index).getPos();
                String sensorStr = index +  "," + i + "," + sensorSpec + "," + pos.x + "," + pos.y;
                wrt.write(sensorStr);
                wrt.newLine();
            }
            wrt.flush();
            wrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("scenario generated successfully!");
    }

    //Generate Example Scenario Using Erdős–Rényi model
    public static Graph erdos(int sensor_count, int sc_count, double p) {
        Graph g = new Graph();
        int n = sensor_count + sc_count;
        ArrayList<Vertex> vertices = new ArrayList<>();
        Random rnd = new Random();

        //create vertices
        for (int i = 0; i < n; i++) {
            g.addVertex(new Vertex());
        }

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                double s = rnd.nextDouble();
                if(s < p) {
                    //create edge
                    g.addEdge(g.getVertices().get(i),g.getVertices().get(j),1);
                }
            }
        }

        //place sink candidates
        ArrayList<Integer> possibleSCs = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            possibleSCs.add(i);
        }
        for (int i = 0; i < sc_count; i++) {
            int k = rnd.nextInt(possibleSCs.size());
            int index = possibleSCs.get(k);
            possibleSCs.remove(k);
            //place a sink candidate on index
            //g.getVertices().get(index).setNode();
        }
        //place sensors
        for (int i = 0; i < possibleSCs.size(); i++) {
            int index = possibleSCs.get(i);
            g.getVertices().get(index).setNode(new SensorNode("S"+i,3,3,0,0,0));
        }

        return g;
    }

}
